From 5c328389d07b531f304d84ce86d4f8f8c32d3b90 Mon Sep 17 00:00:00 2001
From: Matt Roper <matthew.d.roper@intel.com>
Date: Tue, 21 Aug 2018 14:05:09 -0700
Subject: [PATCH 41/44] drm/i915: Drop TSD-specific splash-screen modifications

TSD made a few changes to the i915 splash screen support that that has
been delivered to the rest of IOTG:  they changed the image format from
RGB8888 to an indexed C8 format and added palette information to the end
of the firmware blob.  Although those changes were intended for very
specific TSD customers, they got squashed into the general IOTG
splashscreen support as it landed in the Production Kernel.  This
squashing happened without updating the original commit message, so
unfortunately the history and authorship of these TSD modifications is
missing.

Not only do TSD's modifications break backwards compatibility with the
existing feature that IOTG has been delivering, they also introduce
several defects:

 * Use of 'width' instead of 'pitch' when calculating blob data offsets
 * Assumption that imagesize + palettesize = firmwaresize (in reality,
   firmware size is generally page-aligned and a multiple of 4096,
   breaking this assumption).
 * Failure to check for palettes that are too small (only checks for too
   big)
 * printk usage rather than DRM_DEBUG_* for debugging messages

Since TSD currently intends to carry their modifications separately, we
need to drop their changes from our general purpose kernels to restore
compatibility with our past releases.  If TSD eventually wants to land
their changes in a general-purpose kernel like the PK, they'll need to
come up with an approach that detects which kind of firmware blob is
being loaded and handle it in a backward-compatible way if necessary.

Cc: James Xiong <james.xiong@intel.com>
Cc: Vivek Kasireddy <vivek.kasireddy@intel.com>
Cc: Bob Paauwe <bob.j.paauwe@intel.com>
Fixes: f4ef59764 ("INTERNAL [IOTG] drm/i915/splash: Add support for a splash screen image")
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
Reviewed-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
---
 drivers/gpu/drm/i915/intel_display.c         | 10 +++++++
 drivers/gpu/drm/i915/intel_initial_modeset.c | 44 ++--------------------------
 2 files changed, 12 insertions(+), 42 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index 343990a..f49388c 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -4044,6 +4044,16 @@ static void intel_update_background_color(struct intel_crtc *crtc)
 		    | DRM_RGBA_GREENBITS(background, 10) << 10
 		    | DRM_RGBA_BLUEBITS(background, 10);
 
+		/*
+		 * Set CSC and gamma for bottom color.
+		 *
+		 * FIXME:  We turn these on unconditionally for now to match
+		 * how we've setup the various planes.  Once the color
+		 * management framework lands, it may or may not choose to
+		 * set these bits.
+		 */
+		val |= PIPE_BOTTOM_CSC_ENABLE;
+		val |= PIPE_BOTTOM_GAMMA_ENABLE;
 
 		I915_WRITE(PIPE_BOTTOM_COLOR(crtc->pipe), val);
 	}
diff --git a/drivers/gpu/drm/i915/intel_initial_modeset.c b/drivers/gpu/drm/i915/intel_initial_modeset.c
index 9861824..bc59c33 100644
--- a/drivers/gpu/drm/i915/intel_initial_modeset.c
+++ b/drivers/gpu/drm/i915/intel_initial_modeset.c
@@ -128,8 +128,8 @@ static bool attach_crtc(struct drm_device *dev, struct drm_encoder *encoder,
 	mode_cmd.width = splash_info->width;
 	mode_cmd.height = splash_info->height;
 
-	mode_cmd.pitches[0] = splash_info->pitch;
-	mode_cmd.pixel_format = DRM_FORMAT_C8;
+	mode_cmd.pitches[0] = splash_info->pitch * 4;
+	mode_cmd.pixel_format = DRM_FORMAT_ARGB8888;
 
 	mutex_lock(&dev->struct_mutex);
 	fb = intel_framebuffer_create(splash_info->obj, &mode_cmd);
@@ -398,12 +398,6 @@ static int update_primary_plane_state(struct drm_atomic_state *state,
 {
 	int hdisplay, vdisplay;
 	struct drm_plane_state *primary_state;
-	struct drm_property_blob *blob = NULL;
-	struct drm_color_lut *blob_data;
-	struct drm_crtc_state *crtc_state;
-	struct drm_device *dev = crtc->dev;
-	uint32_t i, palette_size;
-	const char *palette_data;
 	int ret;
 
 	primary_state = drm_atomic_get_plane_state(state, crtc->primary);
@@ -428,40 +422,6 @@ static int update_primary_plane_state(struct drm_atomic_state *state,
 		splash_info->height : vdisplay) << 16;
 	primary_state->rotation = DRM_MODE_ROTATE_0;
 
-	crtc_state = drm_atomic_get_crtc_state(state, crtc);
-
-	/* Color palette is appended after image data, it uses 24-bits for each index entry */
-	palette_size = (splash_info->fw->size - (splash_info->width * splash_info->height)) / 3;
-	printk("Splash size %zu, palette size %u\n", splash_info->fw->size, palette_size);
-	if (0 == palette_size) {
-		DRM_ERROR("Splash image does not contain color palette data\n");
-		return -1;
-	}
-
-	if (palette_size > 256) {
-		DRM_ERROR("Splash image color palette too big\n");
-		return -1;
-	}
-
-	/* i915 expects that palette color will be of 256 size */
-	blob = drm_property_create_blob(dev, sizeof(struct drm_color_lut) * 256, NULL);
-
-	if (IS_ERR(blob)) {
-		blob = NULL;
-		return -1;
-	}
-
-	palette_data = &splash_info->fw->data[splash_info->width * splash_info->height];
-
-	blob_data = (struct drm_color_lut *) blob->data;
-	for (i = 0; i < palette_size; i++) {
-		blob_data[i].red = (*palette_data++) << 8;
-		blob_data[i].green = (*palette_data++) << 8;
-		blob_data[i].blue = (*palette_data++) << 8;
-	}
-
-	drm_atomic_crtc_set_property(crtc, crtc_state, state->dev->mode_config.gamma_lut_property, blob->base.id);
-
 	return 0;
 }
 
-- 
1.9.1

