From ea8ed5dc80d72049f5c5ef8c2fa79e7c5136272b Mon Sep 17 00:00:00 2001
From: Craig Kewley <craigx.kewley@intel.com>
Date: Fri, 18 Aug 2017 09:33:50 +0100
Subject: [PATCH 61/98] Revert "ASoC: Codecs: TDF8532: remove codec"

This reverts commit 306d63eff42073d767aec05c594239e7ab7de3ea.

Conflicts:
	sound/soc/codecs/Kconfig
	sound/soc/codecs/Makefile
---
 sound/soc/codecs/Kconfig   |   5 +
 sound/soc/codecs/Makefile  |   2 +
 sound/soc/codecs/tdf8532.c | 242 +++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 249 insertions(+)
 create mode 100644 sound/soc/codecs/tdf8532.c

diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index a05a58d..d9093fa 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -74,6 +74,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_DIO2125
 	select SND_SOC_DMIC if GPIOLIB
 	select SND_SOC_ES8316 if I2C
+	select SND_SOC_TDF8532 if I2C
 	select SND_SOC_ES8328_SPI if SPI_MASTER
 	select SND_SOC_ES8328_I2C if I2C
 	select SND_SOC_ES7134
@@ -557,6 +558,10 @@ config SND_SOC_DIO2125
 config SND_SOC_DMIC
 	tristate
 
+config SND_SOC_TDF8532
+    tristate "NXP Semiconductors TDF8532 Codec"
+	depends on I2C
+
 config SND_SOC_HDMI_CODEC
 	tristate
 	select SND_PCM_ELD
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 8a6ee2c..fedef12 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -71,6 +71,7 @@ snd-soc-da9055-objs := da9055.o
 snd-soc-dmic-objs := dmic.o
 snd-soc-es7134-objs := es7134.o
 snd-soc-es8316-objs := es8316.o
+snd-soc-tdf8532-objs := tdf8532.o
 snd-soc-es8328-objs := es8328.o
 snd-soc-es8328-i2c-objs := es8328-i2c.o
 snd-soc-es8328-spi-objs := es8328-spi.o
@@ -316,6 +317,7 @@ obj-$(CONFIG_SND_SOC_DA9055)	+= snd-soc-da9055.o
 obj-$(CONFIG_SND_SOC_DMIC)	+= snd-soc-dmic.o
 obj-$(CONFIG_SND_SOC_ES7134)	+= snd-soc-es7134.o
 obj-$(CONFIG_SND_SOC_ES8316)    += snd-soc-es8316.o
+obj-$(CONFIG_SND_SOC_TDF8532) += snd-soc-tdf8532.o
 obj-$(CONFIG_SND_SOC_ES8328)	+= snd-soc-es8328.o
 obj-$(CONFIG_SND_SOC_ES8328_I2C)+= snd-soc-es8328-i2c.o
 obj-$(CONFIG_SND_SOC_ES8328_SPI)+= snd-soc-es8328-spi.o
diff --git a/sound/soc/codecs/tdf8532.c b/sound/soc/codecs/tdf8532.c
new file mode 100644
index 0000000..f94eb98
--- /dev/null
+++ b/sound/soc/codecs/tdf8532.c
@@ -0,0 +1,242 @@
+/*
+ * tdf8532.c  --  driver for NXP Semiconductors TDF8532
+ *
+ * Copyright (C) 2016 Intel Corp.
+ * Author: Steffen Wagner <steffen.wagner@intel.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/acpi.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/pcm_params.h>
+
+struct tdf8532_priv {
+	struct i2c_client *i2c;
+
+	/* Fine to wrap back to 0 */
+	u8 packet_id;
+};
+
+static int tdf8532_cmd_send(struct tdf8532_priv *dev_data, char *cmd_packet,
+		u16 len)
+{
+	int ret;
+	u8 packet_id;
+
+	packet_id = (len > 1) ? cmd_packet[1] : 0;
+
+	ret = i2c_master_send(dev_data->i2c, cmd_packet, len);
+
+	if (ret < 0) {
+		dev_err(&(dev_data->i2c->dev),
+			"i2c send packet(%u) returned: %d\n", packet_id, ret);
+		return ret;
+	}
+
+
+	dev_dbg(&(dev_data->i2c->dev),
+			"i2c send packet(%u) returned: %d\n", packet_id, ret);
+
+	return 0;
+}
+
+static void tdf8532_dai_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct tdf8532_priv *tdf8532 = snd_soc_codec_get_drvdata(codec);
+
+	/*disconnect clock*/
+	unsigned char data[] = {0x02, (tdf8532->packet_id)++, 0x03,
+					0x80, 0x1A, 0x00};
+
+	dev_dbg(codec->dev, "%s\n", __func__);
+
+	tdf8532_cmd_send(tdf8532, data, ARRAY_SIZE(data));
+}
+
+static int tdf8532_dai_trigger(struct snd_pcm_substream *substream, int cmd,
+		struct snd_soc_dai *dai)
+{
+	int ret = 0;
+	struct snd_soc_codec *codec = dai->codec;
+	struct tdf8532_priv *tdf8532 = snd_soc_codec_get_drvdata(codec);
+
+	/*enable or disable 4 channels*/
+	unsigned char data[] = {0x02, (tdf8532->packet_id)++, 0x03,
+					0x80, 0x00, 0x0F};
+
+	dev_dbg(codec->dev, "%s: cmd = %d\n", __func__, cmd);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		data[4] = 0x26;
+		ret = tdf8532_cmd_send(tdf8532, data, ARRAY_SIZE(data));
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+		data[4] = 0x27;
+		ret = tdf8532_cmd_send(tdf8532, data, ARRAY_SIZE(data));
+
+		/*delay 300ms to allow state change to occur*/
+		/*TODO: add state check to wait for state change*/
+		mdelay(300);
+		break;
+	}
+
+	return tdf8532_cmd_send(tdf8532, data, ARRAY_SIZE(data));
+}
+
+static int tdf8532_dai_prepare(struct snd_pcm_substream *substream,
+						struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct tdf8532_priv *tdf8532 = snd_soc_codec_get_drvdata(codec);
+
+	/*attach clock*/
+	unsigned char data[] = {0x02, (tdf8532->packet_id)++, 0x03,
+					0x80, 0x1A, 0x01};
+
+	dev_dbg(codec->dev, "%s\n", __func__);
+
+	return tdf8532_cmd_send(tdf8532, data, ARRAY_SIZE(data));
+}
+
+
+#define MUTE 0x42
+#define UNMUTE 0x43
+
+static int tdf8532_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct tdf8532_priv *tdf8532 = snd_soc_codec_get_drvdata(dai->codec);
+	unsigned char data[] = {0x02, (tdf8532->packet_id)++, 0x03,
+					0x80, MUTE, 0x1F};
+
+	if (!mute)
+		data[4] = UNMUTE;
+	else
+		data[4] = MUTE;
+
+	dev_dbg(&(tdf8532->i2c->dev), "%s\n", __func__);
+
+	return tdf8532_cmd_send(tdf8532, data, ARRAY_SIZE(data));
+}
+
+static int tdf8532_set_fast_mute(struct tdf8532_priv *tdf8532)
+{
+	unsigned char data[] = {
+		0x02, (tdf8532->packet_id)++, 0x06,
+			0x80, 0x18, 0x03, 0x01, 0x02, 0x00};
+
+	return tdf8532_cmd_send(tdf8532, data, ARRAY_SIZE(data));
+}
+
+static const struct snd_soc_dai_ops tdf8532_dai_ops = {
+	.shutdown = tdf8532_dai_shutdown,
+	.trigger  = tdf8532_dai_trigger,
+	.prepare  = tdf8532_dai_prepare,
+	.digital_mute = tdf8532_mute,
+};
+
+static struct snd_soc_codec_driver soc_codec_tdf8532;
+
+static struct snd_soc_dai_driver tdf8532_dai[] = {
+	{
+		.name = "tdf8532-hifi",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 4,
+			.channels_max = 4,
+			.rates = SNDRV_PCM_RATE_48000,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.ops = &tdf8532_dai_ops,
+	}
+};
+
+
+static int tdf8532_i2c_probe(struct i2c_client *i2c,
+		const struct i2c_device_id *id)
+{
+	int ret;
+	struct tdf8532_priv *tdf8532;
+
+	dev_dbg(&i2c->dev, "%s\n", __func__);
+
+	tdf8532 = devm_kzalloc(&i2c->dev, sizeof(*tdf8532),
+			GFP_KERNEL);
+
+	if (NULL == tdf8532)
+		return -ENOMEM;
+
+	tdf8532->i2c = i2c;
+	tdf8532->packet_id = 0;
+
+	i2c_set_clientdata(i2c, tdf8532);
+
+	ret = tdf8532_set_fast_mute(tdf8532);
+
+	if (ret < 0)
+		dev_err(&i2c->dev, "Failed to set fast mute option: %d\n", ret);
+
+	ret = snd_soc_register_codec(&i2c->dev, &soc_codec_tdf8532,
+			tdf8532_dai, ARRAY_SIZE(tdf8532_dai));
+	if (ret != 0)
+		dev_err(&i2c->dev, "Failed to register codec: %d\n", ret);
+
+	return ret;
+
+}
+
+static int tdf8532_i2c_remove(struct i2c_client *i2c)
+{
+	snd_soc_unregister_codec(&i2c->dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id tdf8532_i2c_id[] = {
+	{ "tdf8532", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, tdf8532_i2c_id);
+
+#if CONFIG_ACPI
+static const struct acpi_device_id tdf8532_acpi_match[] = {
+	{"INT34C3", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(acpi, tdf8532_acpi_match);
+#endif
+
+static struct i2c_driver tdf8532_i2c_driver = {
+	.driver = {
+		.name = "tdf8532-codec",
+		.owner = THIS_MODULE,
+		.acpi_match_table = ACPI_PTR(tdf8532_acpi_match),
+	},
+	.probe =    tdf8532_i2c_probe,
+	.remove =   tdf8532_i2c_remove,
+	.id_table = tdf8532_i2c_id,
+};
+
+module_i2c_driver(tdf8532_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC NXP Semiconductors TDF8532 driver");
+MODULE_AUTHOR("Steffen Wagner <steffen.wagner@intel.com>");
+MODULE_LICENSE("GPL");
-- 
1.9.1

